fit <- cmdscale(D,eig=TRUE, k=50)
PlotPoints(fit$points, mylabels, mycolors)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
#1.Determine the neighbors of each point (k-NN)
library(FNN)
knn_data <- get.knn(mydata, k = 10)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
adj_matrix <- matrix(NA, 165, 165)
knn_data_df <- data.frame(idx = knn_data$nn.index,
dist = knn_data$nn.dist)
for(row in c(1:dim(adj_matrix)[1])){
count <- length(knn_data_df[row,])/2
for(i in c(1:(length(knn_data_df[row,])/2))){
col <- knn_data_df[row, i]
adj_matrix[row, col] <- knn_data_df[row, count + i]
adj_matrix[col, row] <- knn_data_df[row, count + i]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library(Rfast)
D <- floyd(adj_matrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=8)
PlotPoints(fit$points, mylabels, mycolors)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
View(mycolors)
View(fittsne)
View(mydata)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
knitr::opts_chunk$set(echo = TRUE)
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
#Load the dataset of 165 words
mydata <- read.csv('data.csv', header = FALSE)
mylabels <- read.csv('labels.txt', header = FALSE)
mycolors <- read.csv('colors.csv', header = FALSE)
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
#1.Determine the neighbors of each point (k-NN)
library(FNN)
knn_data <- get.knn(mydata, k = 10)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
adj_matrix <- matrix(NA, 165, 165)
knn_data_df <- data.frame(idx = knn_data$nn.index,
dist = knn_data$nn.dist)
for(row in c(1:dim(adj_matrix)[1])){
count <- length(knn_data_df[row,])/2
for(i in c(1:(length(knn_data_df[row,])/2))){
col <- knn_data_df[row, i]
adj_matrix[row, col] <- knn_data_df[row, count + i]
adj_matrix[col, row] <- knn_data_df[row, count + i]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library(Rfast)
D <- floyd(adj_matrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=8)
PlotPoints(fit$points, mylabels, mycolors)
knitr::opts_chunk$set(echo = TRUE)
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
#Load the dataset of 165 words
mydata <- read.csv('data.csv', header = FALSE)
mylabels <- read.csv('labels.txt', header = FALSE)
mycolors <- read.csv('colors.csv', header = FALSE)
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
#1.Determine the neighbors of each point (k-NN)
library(FNN)
knn_data <- get.knn(mydata, k = 10)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
adj_matrix <- matrix(NA, 165, 165)
knn_data_df <- data.frame(idx = knn_data$nn.index,
dist = knn_data$nn.dist)
for(row in c(1:dim(adj_matrix)[1])){
count <- length(knn_data_df[row,])/2
for(i in c(1:(length(knn_data_df[row,])/2))){
col <- knn_data_df[row, i]
adj_matrix[row, col] <- knn_data_df[row, count + i]
adj_matrix[col, row] <- knn_data_df[row, count + i]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library(Rfast)
D <- floyd(adj_matrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=8)
PlotPoints(fit$points, mylabels, mycolors)
knitr::opts_chunk$set(echo = TRUE)
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
#Load the dataset of 165 words
mydata <- read.csv('data.csv', header = FALSE)
mylabels <- read.csv('labels.txt', header = FALSE)
mycolors <- read.csv('colors.csv', header = FALSE)
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
#1.Determine the neighbors of each point (k-NN)
library(FNN)
knn_data <- get.knn(mydata, k = 10)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
adj_matrix <- matrix(NA, 165, 165)
knn_data_df <- data.frame(idx = knn_data$nn.index,
dist = knn_data$nn.dist)
for(row in c(1:dim(adj_matrix)[1])){
count <- length(knn_data_df[row,])/2
for(i in c(1:(length(knn_data_df[row,])/2))){
col <- knn_data_df[row, i]
adj_matrix[row, col] <- knn_data_df[row, count + i]
adj_matrix[col, row] <- knn_data_df[row, count + i]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library(Rfast)
D <- floyd(adj_matrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=8)
PlotPoints(fit$points, mylabels, mycolors)
#Principal component analysis
fitPCA <- prcomp(mydata, center = TRUE, scale. = TRUE)
PlotPoints(fitPCA$x[,c(1,2)], mylabels, mycolors)
#t-SNE (T-Distributed Stochastic Neighbor Embedding)
#install.packages('tsne')
library(tsne)
fittsne <- tsne(mydata, k = 2)
PlotPoints(fittsne, mylabels, mycolors)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=8)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=5)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=3)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=4)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=6)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=4)
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
#1.Determine the neighbors of each point (k-NN)
library(FNN)
knn_data <- get.knn(mydata, k = 10)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
adj_matrix <- matrix(NA, 165, 165)
knn_data_df <- data.frame(idx = knn_data$nn.index,
dist = knn_data$nn.dist)
for(row in c(1:dim(adj_matrix)[1])){
count <- length(knn_data_df[row,])/2
for(i in c(1:(length(knn_data_df[row,])/2))){
col <- knn_data_df[row, i]
adj_matrix[row, col] <- knn_data_df[row, count + i]
adj_matrix[col, row] <- knn_data_df[row, count + i]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library(Rfast)
D <- floyd(adj_matrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=4)
PlotPoints(fit$points, mylabels, mycolors)
#Principal component analysis
fitPCA <- prcomp(mydata, center = TRUE, scale. = TRUE)
PlotPoints(fitPCA$x[,c(1,2)], mylabels, mycolors)
#t-SNE (T-Distributed Stochastic Neighbor Embedding)
#install.packages('tsne')
library(tsne)
fittsne <- tsne(mydata, k = 2)
PlotPoints(fittsne, mylabels, mycolors)
#classify plain data
accPlain <- Classify(as.data.frame(mydata[,c(1,2)]), mycolors$V1, 50)
#classify ISOMAP
accISOMAP <- Classify(as.data.frame(fit$points), mycolors$V1, 50)
#classify PCA
accPCA <- Classify(as.data.frame(fitPCA$x), mycolors$V1, 50)
#classify t-SNE
accTSNE <- Classify(as.data.frame(fittsne), mycolors$V1, 50)
#PLOT results
print(paste("Plain ACC:", mean(accPlain)))
print(paste("ISOMAP ACC:", mean(accISOMAP)))
print(paste("PCA ACC:", mean(accPCA)))
print(paste("t-SNE ACC:", mean(accTSNE)))
library(Biostrings)
install.packages("Biostrings")
library(tidyverse)
install.packages("swirl")
library(swirl)
install.packages("swirl")
install.packages("RCurl")
install.packages("RCurl")
install.packages("swirl")
swirl()
swirl
library(swirl)
swirl()
swirl()
install_course("Getting and Cleaning Data")
swirl()
getwd()
setwd("projects/tt/childcare/")
knitr::opts_chunk$set(echo = TRUE)
#load dataset
childcare_costs <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-05-09/childcare_costs.csv')
counties <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-05-09/counties.csv')
source("print_cormats.R")
colSums(is.na(childcare_costs))
colSums(is.na(childcare_costs))
#load dataset and required functions
library(tidyverse)
source("print_cormats.R")
# variables describing childcare costs contain roughly 1/3 of missing values
colSums(is.na(childcare_costs))
# making a separate datasets for those variables and for the rest
rest <- select(childcare_costs, county_fips_code:femp_p)
chc <- select(childcare_costs, mcsa:mfcc_preschool)
print_cormats(rest, 0.5, "p")
install.packages("reshape2")
library(reshape2)
print_cormats(rest, 0.5, "p")
print_cormats(rest, 0.5, "s")
print_cormats(rest, 0.5, "p")
print_cormats(rest, 0.5, "s")
print_cormats(rest, 0.5, "p")
print_cormats(rest, 0.5, "s")
print_cormats(chc, 0.5, "s")
print_cormats(rest, 0.5, "s")
?sprintf
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
source("print_cormats.R")
print_cormats(rest, 0.5, "s")
print_cormats(rest, 0.5, "p")
print_cormats(rest, 0.5, "s")
print_cormats(rest, 0.6, "s")
print_cormats(rest, 0.65, "s")
print_cormats(rest, 0.6, "s")
print_cormats(rest, 0.6, "p")
print_cormats(rest, 0.6, "s")
